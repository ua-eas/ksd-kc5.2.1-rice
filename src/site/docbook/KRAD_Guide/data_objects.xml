<?xml version='1.0' encoding='UTF-8'?> 
<!--

    Copyright 2005-2014 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter xml:id="data_objects" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook"  version="5.0">
    <title> Data Objects and Persistence </title>
    <note>
        <para>This document outlines the KRAD Data Framework as of Kuali Rice 2.4+. If you are
            working with older KRAD code and OJB, you will want to reference this document in pre
            2.4 versions of the KRAD Guide. See <link xlink:show="new"
                xlink:href="http://rice.kuali.org/docs">http://rice.kuali.org/docs</link> for links
            to older versions of the Kuali Rice documentation.</para>
    </note>
    <section>
        <title>Data Framework</title>
        <para>KRAD includes a "krad-data" module which provides data and persistence-related
            services. The data framework provided by this module has a number of goals:<orderedlist>
                <listitem>
                    <para>Provide CRUD (Create, Read, Update, Delete) operations for data.</para>
                </listitem>
                <listitem>
                    <para>Maintain a Metadata repository for storing additional information about
                        data objects and their attributes.</para>
                </listitem>
                <listitem>
                    <para>Provide a mechanism to integrate custom persistence and metadata
                        providers.</para>
                </listitem>
                <listitem>
                    <para>Include a default implementation based on the Java Persistence API
                        (JPA).</para>
                </listitem>
            </orderedlist>As stated, it is intended that data which is consumed and processed by a
            KRAD application may be stored in any number of backend data stores or accessed using
            any number of different technologies.</para>
        <para>For many KRAD applications, this data will be stored in a relational database and
            accessed using the Java Persistence API (JPA). This is the default persistence
            technology that KRAD supports, however the design of the data framework facilitates
            integration with other technologies (plain JDBC and SQL, spring-data, web services,
            etc.) and backend data stores (key-value stores, document databases, object databases,
            etc.). This is accomplished through a service provider interface (SPI) that allows for
            the creation and integration of custom providers.</para>
        <para>In addition to providing persistence operations, the krad-data module also provides a
            Metadata repository which stores various bits of metadata about the data objects that it
            is managing. Specifically, this includes information about what the keys and
            relationships are between data objects. It also contains information like human-readable
            labels for data object properties and constraints related to the valid representation of
            the data.</para>
        <para>The krad-data module provides an API to interact with data objects and their metadata
            which is then consumed by the other components within the KRAD framework whenever they
            need to perform data-related operations. This API can also be used elsewhere within the
            application when it needs to interact with its data objects.</para>
    </section>
    <section>
        <title> Data Objects </title>
        <section>
            <title>Data Objects</title>
            <para>Enterprise applications generally have a large number of CRUD (Create, Read,
                Update, Delete) operations; therefore, the access of data is a very important
                concern of development. KRAD builds on top of other tools to provide general
                facilities that greatly reduce the development time. These facilities are known as
                the KRAD Persistence Framework. </para>
            <para>The foundation of the KRAD Persistence Framework is the third party ORM (Object
                Relational Mapping) tool. ORM tools target the persistence of data with a relational
                database. This is achieved by mapping a Java object that contains the data to one or
                more database tables. When a persistence operation is requested, the ORM tool performs
                the work of translating the request along with the corresponding object(s) to the
                necessary DML statement. This provides a great advantage to the application as it
                generally requires no database dependent code (database specific code might be required
                in certain cases). </para>
            <para>In order to prepare our application for persisting data using an ORM tool, we must
                build the objects that will hold the application data. From the established data model,
                we can determine the objects needed using a mapping strategy. Although the strategies
                and options available depend on the ORM solution we are using, generally we have the
                following mapping options: <orderedlist>
                    <listitem>
                        <para> One table to one object </para>
                    </listitem>
                    <listitem>
                        <para> One table to multiple objects (polymorphism) </para>
                    </listitem>
                    <listitem>
                        <para> Multiple tables to one object </para>
                    </listitem>
                </orderedlist></para>
            <para>Once we have determined how an object will relate with its database table(s), each
                object property is associated with a table column through configuration. This
                configuration will also give the ORM tool information on data type conversion and
                constraints. The final piece to our object mapping is specifying any relationships.
                This includes one-to-one, one-to-many, and many-to-many relationships. </para>
            <tip><para>Referential Integrity: It is not required to have referential integrity set up in the database
                    for relationships declared for the persistent metadata. However, it is generally
                    good practice to do so.</para></tip>
            <para>Now let's set aside the mapping concerns and have a closer look at our 'data' objects.
                Technically, these objects are not complex at all. First, they must adhere to the POJO
                (Plain Old Java Object) and JavaBean guidelines. These guidelines are as follows: <orderedlist>
                    <listitem>
                        <para>Is Serializable (implements the java.io. Serializable interface) </para>
                    </listitem>
                    <listitem>
                        <para>Has a no-arg constructor </para>
                    </listitem>
                    <listitem>
                        <para>Provides property getter and setter methods using the conventional
                            (get{PropertyName} for getter, set{PropertyName} for setter, and
                            is{PropertyName} for Booleans) </para>
                    </listitem>
                </orderedlist></para>
            <para>In addition to the 'primitive' property types a data object may contain, a data
                object may also be composed of nested data objects (representing a one-to-one
                relationship), or a collection of data objects (representing a one-to-many
                relationship). </para>
            <tip><para><emphasis role="keyword">Related Data Objects</emphasis>: It is important to setup the related
                    data object properties. As we will see later on, the framework can take care of
                    many things for us automatically based on the metadata derived from these
                    relationships. </para></tip>
            <para>KRAD refers to any object that provides data as a 'Data Object'. Data objects provide
                a very central role in an enterprise application. Within the suggested KRAD
                architecture, they are not bound to just the data access layer, but can freely move
                between the other application layers as well. This means we can use data objects in our
                services, and we can use them to build our user interfaces. </para>
            <tip><para><emphasis role="keyword">'Data Object'</emphasis>: The 'Data Object' term can refer to objects
                    that are mapped to a persistence mechanism, but also might not be. For example,
                    it might be an object whose data is assembled by a service call, which in turn
                    interacts with other persisted objects or other services. This flexibility is
                    important for allowing other KRAD modules to be used with a variety of data
                    sources and strategies.</para></tip>
            <para><emphasis role="bold">Best Practice</emphasis>: Keep data objects simple! Try to avoid
                introducing any business logic or presentation logic into the objects. </para>
        </section>
        <section>
            <title>Data Objects </title>
            <para>A special type of object in KRAD is known as a Data Object. There are two
                primary types of data object: those that persist to the database and those that
                do not. Generally, when creating a new data object, it is more convenient to extend
                one of the provided base classes that implement the necessary interfaces. For
                persistable objects, this base class is org.kuali.rice.krad.bo.DataObjectBase.
                Within this base class, default implementations for the persistable methods exist
                along with properties for the common fields required for all persisted objects.
                These are described in more detail later on in this section. Data objects that
                do not persist to the database do not have to extend any particular class. </para>
            <tip>
                <para><emphasis role="keyword">Business Objects</emphasis>: Earlier versions of
                    Rice using OJB used to require that all data objects extend the sub-interfaces
                    of org.kuali.rice.krad.bo.BusinessObjectBase (such as
                    org.kuali.rice.krad.bo.PersistableBusinessObjectBase or
                    org.kuali.rice.krad.bo.TransientBusinessObjectBase), due to the framework
                    requiring all objects to be business objects (including the UI generation). With
                    version 2.0 of Rice with KRAD and JPA, this restriction no longer exists; therefore
                    there is really no need for these extensions. </para>
            </tip>
            <para>In order to take advantage of all the features KRAD provides, it is recommended
                that all persistable objects (and therefore tables) contain two properties: <orderedlist>
                    <listitem>
                        <para>Version Number – This property holds a version for the record that is
                            maintained by the ORM tool to perform optimistic locking. The number is
                            initially set to 0. Each time the record is updated, the version number
                            is incremented. Before updating the record, the ORM tool performs a
                            comparison between the version number on the data object, and the
                            version number of the record in the database. If they are different, the
                            tool knows the record has been updated since the record was pulled and
                            throws an optimistic lock exception. </para>
                    </listitem>
                    <listitem>
                        <para>Object Id – This property holds a GUID value for each record in the
                            database. This is used in the framework as an alternate key for the
                            record. Example usages of the object id include the notes and
                            attachments framework. Notes are associated with a record by its object
                            id. Another example is its use within the multi-value lookup framework.
                            Selected records are identified and retrieved based on their unique
                            object ids. </para>
                    </listitem>
                </orderedlist></para>
        </section>
        <section>
            <title>Special Data Objects </title>
            <para>Additional functionality exists for a few special types of data objects. One
                of these special types is data objects that have an active status. That is, each
                record has a state of active (which generally means the record is valid for using)
                or inactive (meaning the record should not be used due to being old or not currently
                valid). Objects of this type should implement the Inactivatable interface. This
                interface requires the methods isActive() and setActive(Boolean active) to be
                implemented. </para>
            <para>The simplest form of inactivatable data objects are those that maintain a
                single field that indicates the active status as a Boolean field. Another common
                case is that of an active date range (also known as effective dating). These objects
                maintain two fields that work together for determining the active status. This first
                of these fields is the active begin date which indicates the date on which the
                record becomes active. This field can have a null value indicating the record is
                active for all dates before the end date. The second field is the active end date
                which indicates the date on which the record becomes inactive. This field can have a
                null value indicating the record has no inactive date set. </para>
            <para> Record is active if:
                <programlisting linenumbering = "numbered">(activeFromDate == null ||
    asOfDate >= activeFromDate.getMillis()) &amp;&amp;  (activeToDate == null ||
    asOfDate &lt; activeToDate.getMillis());   </programlisting>
                where the asOfDate is the current date or a date we wish to simulate the active
                check for. </para>
            <para>For inactivatable data objects that use effective dating, the
                org.kuali.rice.krad.bo.InactivatableFromToImpl class can be extended which holds the
                necessary properties and implements the logic necessary to determine the active
                status (note that this class implements the Inactivatable and InactivatableFromTo
                interfaces). </para>
            <para>When an object is marked as inactivatable, KRAD will give us some nice features
                for handling the active status: <itemizedlist>
                    <listitem>
                        <para><emphasis role="bold">Validation of active status for foreign key
                                fields </emphasis></para>
                        <para>As we will see later on in the section 'Automatic Validation', KRAD
                            can perform a lot of the common validation tasks for us. One of these is
                            known as default existence checks. This is validation that is performed
                            on one or more user inputted fields to verify the value given exists in
                            the related database table. To perform this validation, the framework
                            uses the configured relationship for the inputted fields (inputted
                            fields are the foreign keys). In addition to performing the existence
                            checks, we can ask for the active status to be verified as well. If the
                            record exists but the active flag is false, an error message will be
                            displayed to the user. </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Inactivation Blocking </emphasis></para>
                        <para>Changing the active status for a record to false (or inactive) is
                            known as inactivation. Problems with data integrity can occur if we
                            inactivate a record that is referenced (by a foreign key relationship)
                            by another active record. For these cases we want to ensure the record
                            with the relationship is inactivated before the related record. Using a
                            feature known as Inactivation Blocking we can disallow the user from
                            inactivating a record when this condition exists. </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Inactive Collection Row Filtering</emphasis>
                        </para>
                        <para>When displaying a collection with the UIF (User Interface Framework)
                            whose items implement the Inactivatable interface, a filter is presented
                            allow the user to view all records or only those that are active.
                        </para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">Key Value Finders</emphasis>
                        </para>
                        <para>UI controls like the select and radio group can get their option
                            values from a class known as KeyValueFinder (more on this in 'Types of
                            Controls'). For easy building of these option classes, the UIF provides
                            a generic configurable KeyValueFinder that will exclude inactive records
                            from the options list if the option providing class implements
                            Inactivatable. </para>
                    </listitem>
                </itemizedlist></para>
            <para>Another special type of data objects are code/name objects. These objects all
                contain a field that represents a code, and a field that gives the name for that
                code (or description). In many cases these are the only two fields present. Data
                objects of this type should implement the org.kuali.rice.krad.bo.KualiCode interface
                (or extend org.kuali.rice.krad.bo.KualiCodeBase). When presenting code values that
                have a related object of type KualiCode, the framework will do translation to
                display the name or the code and name. </para>
            <tip><para><emphasis role="bold">Planned Feature</emphasis></para>
                <para><emphasis role="bold">Code Table:</emphasis> In the future KRAD will provide
                    the facilities for storing KualiCode objects in a single code table. This will
                    allow new codes to be created quickly (without the need for a table and
                    mapping). </para></tip>
        </section>
        <section>
        	<title>Extending Data Objects</title>
        	<para>At times, there is a need to add additional attributes to existing objects in Rice or 
        	in a Rice-based client application.  Since not all objects can be subclassed safely (as some
        	code may instantiate the base classes directly, we recommend creating an &quot;extension&quot;
        	object with the additional attributes.  This object will need to have the same primary key 
        	field(s) as the class being extended.</para>
        	<para>Rice helps to faciltate this through two additional features.
        	</para>
       		<itemizedlist>
               	<listitem><para>The base class used for KRAD data objects 
               	(<emphasis role="keyword">org.kuali.rice.krad.bo.DataObjectBase</emphasis>) contains a placeholder
               	extensionObject property that can be used to traverse to your extension object.</para></listitem>
               	<listitem><para>A special annotation <emphasis role="keyword">@ExtensionFor</emphasis> which is used
               	on your extension class in order to link it to the base system data object.  It links the objects
               	automatically within the JPA layer and sets the extension object to JOIN-fetch with the
               	extended object.</para></listitem>
            </itemizedlist>
            <section>
            	<title>Usage</title>
            	<para>To make use of this feature, you need to do a few things.</para>
            	<orderedlist>
            		<listitem><para>Create a table for your extension attributes.  This table's primary key
            			must have the same fields and datatypes as the data object you are extending.</para>
            			<tip><para><emphasis role="bold">Warning</emphasis></para>
            				<para>Do NOT add a referential integrity constraint back to the main table.
            					While that is a logically correct relationship, we do not have full control
            					over the order in which the ORM tools insert the records in this case.
            					As such, the system may attempt to insert your extension record first.
            					(Which would fail if such a constraint were in place.)</para></tip>
            		</listitem>
            		<listitem><para>Create a Java class to represent the extension and annotate normally for JPA.</para></listitem>
            		<listitem><para>Add the <emphasis role="keyword">@ExtensionFor</emphasis> to the class.  
            		See below for examples.</para></listitem>
            	</orderedlist>
            </section>
            <section>
            	<title>@ExtensionFor Annotation</title>
            	<para>There are two properties on the <emphasis role="keyword">@ExtensionFor</emphasis> annoation.</para>
            	<itemizedlist>
            		<listitem><para><emphasis role="bold">value (default)</emphasis> : The class to which this extension 
            		should be attached.</para></listitem>
            		<listitem><para><emphasis role="bold">extensionPropertyName</emphasis> : On the above class, 
            		the property with this name should be used to make the attachment.  This property must
            		be a superclass of your actual extension object.  (Baseline setup simply has the property
            		set up as an Object.)</para></listitem>
            	</itemizedlist>
	            <section role="NotInToc">
	            	<title>Examples</title>
	            	<para><emphasis role="bold">Using Default Extension Property</emphasis></para>
	            	<programlisting>
@Entity
@Table(name="TRV_ACCT_EXT")
@ExtensionFor(Account.class)
public class AccountExtension { ...} 
	            	</programlisting>
	            	<para><emphasis role="bold">Using Custom Extension Property</emphasis></para>
	            	<programlisting>
@Entity
@Table(name="TRV_ACCT_EXT")
@ExtensionFor(value=Account.class,extensionPropertyName="extensionObject")
public class AccountExtension { ...} 
	            	</programlisting>
	            </section>
            </section>
        </section>
        <section role="NotInToc">
            <title>RECAP</title>
            <itemizedlist>
                <listitem>
                    <para>Data objects are standard JavaBeans that hold application data. Generally,
                        the data from these objects is persisted to the database with use of an ORM
                        tool.</para>
                </listitem>
                <listitem>
                    <para>Metadata provides the mapping between a data object class and a database
                        table. Each object property is mapped to a table field, and one-to-one,
                        one-to-many, and many-to-many relationships can be configured. </para>
                </listitem>
                <listitem>
                    <para>Data objects are a central piece to the KRAD framework. These objects and
                        their metadata are used to provide features such as inquiries, lookups,
                        maintenance, and validation. </para>
                </listitem>
                <listitem>
                    <para>All persistable data objects should have the version number and object id
                        properties. </para>
                </listitem>
                <listitem>
                    <para>Data objects that have an active status implement the Inactivatable
                        interface.</para>
                </listitem>
                <listitem>
                    <para>KRAD provides additional functionality for inactivatable objects. </para>
                </listitem>
                <listitem>
                    <para>KualiCode represents a data object that has a code and name property.
                    </para>
                </listitem>
                <listitem>
                    <para>The @ExtensionFor annotation allows for extending baseline data objects without
                    making any changes to the baseline system code or configuration.</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Java Persistence API</title>
        <section>
            <title>KRAD Entity Manager Factories</title>
            <para><emphasis role="bold">KradEntityManagerFactoryBean</emphasis></para>
            <para>
                The KradEntitymanagerFactory is a KRAD-managed entity manager factory bean which can be used to configure a JPA
                persistence unit using the Spring Framework. This implementation does not support the use of a custom
                PersistenceUnitManager, but rather stores and manages one internally. This is intended to be an alternative to
                direct usage of Spring's LocalContainerEntityManagerFactoryBean in order to make JPA configuration with
                KRAD simpler.
            </para>
            <para><emphasis role="bold">Configuration</emphasis></para>
            <para>
                The minimal configuration for the KRADEntityManagerFactory is a persistence unit name, JTA or non-JTA datasource,
                and JPA vendor adapter.
            </para>
            <note><para>Persistence unit names must be unique</para></note>
            
            <para><emphasis role="bold">Behavior</emphasis></para>
            <para> When leveraging this class, persistence.xml files are not used. Rather,
                persistence unit configuration is loaded via the various settings provided on this
                factory bean which contain everything needed to create the desired persistence unit
                configuration in the majority of cases. If a KRAD application needs more control
                over the configuration of the persistence unit or wants to use persistence.xml and
                JPA's default bootstrapping and classpath scanning behavior, an EntityManagerFactory
                can be configured using the other classes provided by the Spring framework or by
                other means as needed. See the LocalContainerEntityManagerFactoryBean class for an
                alternative approach. </para>
            <para> Only one of JTA or non-JTA datasource can be set. Depending on which one is set,
                the underlying persistence unit will have it's
                javax.persistence.spi.PersistenceUnitTransactionType set to either RESOURCE_LOCAL or
                JTA. If both of these are set, then this class will throw an IllegalStateException
                when the afterPropertiesSet method is invoked by the Spring Framework. </para>
            <para> Elsewhere, this class delegates to implementations of
                LocalContainerEntityManagerFactoryBean and DefaultPersistenceUnitManager, so
                information on the specific behavior of some of the settings and methods on this
                class can be found on the javadoc for those classes as well. </para>
            <para><emphasis role="bold">JPA Property Defaults</emphasis></para>
            <para>
                When the afterPropertiesSet method is invoked, this class will scan the current config context for JPA
                properties and make them available to the persistence unit. It will combine these with any properties that were set
                directly on this factory bean via the setJpaProperties(java.util.Properties) or the setJpaPropertyMap(java.util.Map)
                methods.
            </para>
            <para>
                This scanning occurs in the following order, items later in the list will override any properties from earlier if
                they happen to set the same effective property value:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        Scan ConfigContext for properties that begin with "rice.krad.jpa.global." For any found, strip off this prefix
                        prior to placing it into the JPA property map.
                    </para>
                </listitem>
                <listitem>
                    <para> Scan ConfigContext for properties that begin with
                        "rice.krad.jpa.&lt;persistence-unit-name&gt;" where "persistence-unit-name"
                        is the configured name of this persistence unit. For any found, strip off
                        this prefix prior to placing it into the JPA property map. </para>
                </listitem>
                <listitem>
                    <para>
                        Invoke loadCustomJpaDefaults(java.util.Map) method to allow for possible subclass customization of JPA
                        property defaults.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Load the JPA properties configured via setJpaPropertyMap(java.util.Map) method and
                        setJpaProperties(java.util.Properties) method. It is potentially non-deterministic which of these setters will
                        take precedence over the other, so it is recommended to only invoke one of them on a given instance of this
                        factory bean.
                    </para>
                </listitem>
            </orderedlist>
            <para><emphasis role="bold">KradEclipseLinkEntityManagerFactoryBean</emphasis></para>
            <para>
                The KradEclipseLinkEntityManagerFactory is a KRAD-managed enitity manager factory which can be used to configure an
                EclipseLink persistence unit using JPA. This class inherits from the KradEntityManagerFactoryBean class, but adds the
                following behavior:
            </para>
            <orderedlist>
                <listitem>
                    <para>Sets the jpa vendor adapter to an EclipsLink vendor adapter</para>
                </listitem>
                <listitem>
                    <para>
                        Detects if Java Transation API (JTA) is being used and, if so sets a JPA property value accordingly to allow
                        EclipseLink integration with the Java Transation API
                    </para>
                </listitem>
                <listitem>
                    <para>Configures an EclipsLink customizer to allow a configurable sequence management strategy.</para>
                </listitem>
                <listitem>
                    <para>Disables the shared cache.</para>
                </listitem>
            </orderedlist>
            <para><emphasis role="bold">Typical KradEclipseLinkEntityManagerFactoryBean
                    Configuration</emphasis></para>
            <programlisting>
<![CDATA[
<bean id="sampleApplicationDataSource" class="org.kuali.rice.core.framework.persistence.jdbc.datasource.PrimaryDataSourceFactoryBean" lazy-init="true">
	<property name="preferredDataSourceParams">
		<list>
			<value>sampleApplication.datasource</value>
		</list>
	</property>
	<property name="preferredDataSourceJndiParams">
		<list>
			<value>sampleApplication.datasource.jndi.location</value>
		</list>
	</property>
	<property
		name="serverDataSource"
		value="false" />
</bean>

<bean id="jpaPersistenceUnitName" class="java.lang.String">
		<constructor-arg value="sample-application" />
</bean>

<util:list id="sampleJpaPackagesToScan">
	<value>org.kuali.rice.krad.sampleapp.jpa</value>
	<value>org.kuali.rice.krad.sampleapp.bo</value>
</util:list>

// empty since we are doing package scans
<util:list id="managedClassNames" />

<bean id="entityManagerFactory" class="org.kuali.rice.krad.data.jpa.eclipselink.KradEclipseLinkEntityManagerFactoryBean"
    p:jtaDataSource-ref="sampleApplicationDataSource" p:persistenceUnitName-ref="jpaPersistenceUnitName"
    p:packagesToScan-ref="sampleJpaPackagesToScan" p:managedClassNames-ref="managedClassNames" />
]]>
            </programlisting>
            <para><emphasis role="bold">EclipseLink Bytecode Weaving Concerns</emphasis></para>
            <para>In order to leverage a number of features provided by EclipseLink, bytecode
                weaving of the JPA entities in the persistence unit must be performed. EclipseLink
                uses this technique to enable lazy loading, change tracking, fetch groups, and
                internal optimizations for JPA entites. Weaving is the technique that is used to
                perform this manipulation of the bytecode of compiled Java classes.</para>
            <para>You can read more about it in the <link
                    xlink:href="http://www.eclipse.org/eclipselink/documentation/2.5/concepts/app_dev007.htm#CCHJEDFH"
                    >EclipseLink documentation on Weaving</link>.</para>
            <para>There are essentially four approaches that you can take:</para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>No Weaving</para>
                    </listitem>
                    <listitem>
                        <para>Load-Time Weaving</para>
                    </listitem>
                    <listitem>
                        <para>Static Weaving</para>
                    </listitem>
                    <listitem>
                        <para>Hybrid</para>
                    </listitem>
                </orderedlist>
            </para>
            <para>Except in the case of very simple applications, performing bytecode weaving is
                recommended.</para>
            <para>If you are building library code which contains JPA entities, then static weaving
                is a good choice as it will allow you to distribute your JARs with "pre-weaved"
                class files. EclipseLink provides an <link
                    xlink:href="https://wiki.eclipse.org/EclipseLink/UserGuide/JPA/Advanced_JPA_Development/Performance/Weaving/Static_Weaving"
                    >Ant task for performing this</link>. If you are using Maven instead there is a
                plugin you can use. A typical configuration of the plugin would look like
                this:</para>
            <para>
                <programlisting><![CDATA[
<plugin>
  <groupId>au.com.alderaan</groupId>
  <artifactId>eclipselink-staticweave-maven-plugin</artifactId>
  <version>1.0.4</version>
    <executions>
      <execution>
        <goals>
          <goal>weave</goal>
        </goals>
        <phase>process-classes</phase>
        <configuration>
          <logLevel>FINER</logLevel>
          <persistenceXMLLocation>META-INF/persistence-weaving.xml</persistenceXMLLocation>
        </configuration>
      </execution>
    </executions>
  </version>
</plugin>
]]></programlisting>
            </para>
            <para>Note the reference to a "persistence-weaving.xml" file. Static weaving <emphasis
                    role="bold">requires</emphasis> a JPA-standard persistence.xml file in order to
                identify the entities, mapped super classes, and embedded classes which need to be
                bytecode weaved. If you are using the KradEclipseLinkEntityManagerFactoryBean, then
                it is assembling the persistence unit for you programatically and there is no
                persistence.xml file. We can work around this by defining a separate
                persistence-weaving.xml file that simply contains a list of the JPA entities, mapped
                superclasses, and embeddables in our persistence unit. A typical file might look
                like this:</para>
            <para>
                <programlisting>&lt;persistence ...>
  &lt;persistence-unit name="...">
    &lt;class>my.package.JpaEntityOne&lt;/class>
    &lt;class>my.package.JpaEntityTwo&lt;/class>
    ...
  &lt;/persistence-unit>
&lt;/persistence></programlisting>
            </para>
            <para>If your JPA entity code will only be consumed internally by your application, then
                load-time weaving is easy to configure and likely the best choice. It is recommend
                to do this using the capabilities that the Spring framework provides for load-time
                weaving. See the <link
                    xlink:href="http://docs.spring.io/spring/docs/3.2.8.RELEASE/spring-framework-reference/htmlsingle/#context-load-time-weaver"
                    >Spring documentation on registering a LoadTimeWeaver</link>.</para>
            <para>For the "hybrid" approach, you simply configure both static and load-time weaving.
                They can work in conjunction with each other. This is primarily useful if you are
                developing in an IDE environment. Whenever you change an entity class in the IDE it
                will recompile that class and the newly compiled version will be missing any
                bytecode weaving until either static weaving is performed (by executing the Ant task
                or Maven goal) or a load time weaver is used when the class is loaded. In the hybrid
                approach, the load-time weaver simply acts as a backup for those situations where
                the statically weaved bytecode gets blown away by an incremental IDE compile.</para>
            <para>This hybrid approach is actually the technique that Kuali Rice uses internally
                since it distributes libraries containing statically-weaved JPA entities. If you are
                distributing libraries for usage by others and would like to use the hybrid
                approach, you might also consider looking at the
                org.kuali.rice.core.framework.util.spring.OptionalContextLoadTimeWeaver class to
                avoid requiring any clients of your libraries to also have to configure load-time
                weaving just to use your library.</para>
        </section>
        <section>
            <title>Persistence Providers</title>
            <para>Persistence providers are implementations of the Java Persistence API (JPA) specification.</para>
            <note><para>Currently Kuali Rice only has support for the EclipseLink JPA vendor.</para></note>
            <para>When creating a new instance of the JpaPersistenceProvider, a reference to a "shared" entity manager like that created by
                Spring's org.springframework.orm.jpa.support.SharedEntityManagerBean must be injected. Additionally, a reference to a 
                DataObjectService must be injected as well.</para>
            <para><emphasis role="bold">Spring JpaPersistenceProvider Setup</emphasis></para>
            <programlisting>
<![CDATA[
<util:list id="location.managedClassNames">
   <value>org.kuali.rice.foo.FooBo</value>
   <value>org.kuali.rice.foo.BarBo</value>
</util:list>

<bean id="location.entityManagerFactory" class="org.kuali.rice.krad.data.jpa.eclipselink.KradEclipseLinkEntityManagerFactoryBean"
    p:jtaDataSource-ref="locationDataSource" p:persistenceUnitName="rice.location"
    p:managedClassNames-ref="location.managedClassNames"/>

<bean id="dataObjectService" class="org.kuali.rice.krad.data.KradDataFactoryBean"/>
            
<bean id="sharedEntityManager" class="org.springframework.orm.jpa.support.SharedEntityManagerBean"
    p:entityManagerFactory-ref="entityManagerFactory" />

<bean id="jpaPersistenceProvider" class="org.kuali.rice.krad.data.jpa.JpaPersistenceProvider"
    p:dataObjectService-ref="dataObjectService" p:sharedEntityManager-ref="sharedEntityManager"/>
]]>
        </programlisting>
            <para>The JpaPersistenceProvider must then be registered with the Provider Registry in one of two ways:</para>
            <orderedlist>
                <listitem><para>Use a ProviderRegistar bean</para></listitem>
                <listitem><para>Inject into the ModuleConfiguration</para></listitem>
            </orderedlist>
            <para><emphasis role="bold">Inject into ProviderRegistar bean</emphasis></para>
            <programlisting>
<![CDATA[
<bean id="location.providerRegistrar" class="org.kuali.rice.krad.data.provider.ProviderRegistrar">
    <property name="providerRegistry" ref="providerRegistry" />
    <property name="providers">
      <util:list>
        <ref bean="location.jpaPersistenceProvider" />
        <ref bean="location.metadataProvider" />
      </util:list>
    </property>
  </bean>
 ]]>
        </programlisting>
            <para><emphasis role="bold">Inject into the ModuleConfiguration</emphasis></para>
            <programlisting>
<![CDATA[
<bean id="locationModuleConfiguration" class="org.kuali.rice.krad.bo.ModuleConfiguration">
    <property name="namespaceCode" value="location"/>
    <property name="dataSourceName" value="locationDataSource"/>
    ...
    <property name="providers">
      <list>
        <ref bean="jpaPersistenceProvider"/>
        <ref bean="metadataProvider"/>
      </list>
    </property>
    ...
</bean>      
]]>
        </programlisting>
        <para>
            Transactions are handled by default via this configuration.  The
            <emphasis role="keyword">JpaPersistenceProvider</emphasis> uses Spring's
            <emphasis role="keyword">@Transactional</emphasis> annotation along with the corresponding setup to ensure
            that all calls through the <emphasis role="keyword">DataObjectService</emphasis> are wrapped in
            transactions.  Any alternate persistence provider that supports transactions will also be handled in this
            manner.  In other words, the <emphasis role="keyword">DataObjectService</emphasis> acts as a transactional
            boundary and uses the default <emphasis role="keyword">Propagation.REQUIRED</emphasis> to ensure that either
            a transaction exists or a new one is created.
        </para>
        <para>
            For some objects, such as <emphasis role="keyword">DocumentType</emphasis> which depends on parent types of
            the same class, KRAD uses optimistic locks on the parent type to force any transaction that has updated the
            parent type to finish before creating a new transaction to update the current type.
        </para>
        </section>
        <section>
            <title>Metadata Provider</title>
            <para>
                To assist with the processing and displaying of information, Kuali Rice comes with a JPA-based
                metadata provider that extracts information from the JPA annotations and infers information about
                object keys, attributes, collections, relationships, and default display values.  This is an essential
                part of any JPA-based setup, so any application implementing JPA in Rice must at the very least hook
                up to the metadata provider.
            </para>
            <para>
                In the configuration for each module, the following must be included to hook into the provider.
                <programlisting>&lt;property name="providers">
    &lt;list>
        &lt;ref bean="jpaPersistenceProvider"/>
        &lt;ref bean="metadataProvider"/>
    &lt;/list>
&lt;/property></programlisting>
                The key here is the <emphasis role="keyword">metadataProvider</emphasis> which is a list that includes
                the JPA metadata provider, among others.  By default, this points back into Rice to
                <programlisting>&lt;bean id="metadataProviderJpa"
    class="org.kuali.rice.krad.data.jpa.eclipselink.EclipseLinkJpaMetadataProviderImpl"
    p:entityManager-ref="sharedEntityManager" /></programlisting>
                which uses the EclipseLink reference implementation classes to populate metadata objects.  Only applications
                that wish to use a different JPA implementation would ever have to override this bean.
            </para>
        </section>
        <section>
            <title>Custom Providers</title>
            <para>
                Implementers can create their own providers for persistence and metadata by implementing certain
                interfaces.  Any persistence provider should use the
                <emphasis role="keyword">org.kuali.rice.krad.data.provider.PersistenceProvider</emphasis> interface
                which requires implementing methods for finding, saving, and deleting data objects.  Singleton metadata
                providers should use the
                <emphasis role="keyword">org.kuali.rice.krad.data.provider.MetadataProvider</emphasis> interface which
                requires implementing methods for retrieving metadata for a certain type.  In addition, the
                <emphasis role="keyword">org.kuali.rice.krad.data.provider.CompositeMetadataProvider</emphasis>
                interface defines a container of several singleton metadata providers.  This interface is mainly used in
                situations where there is custom logic to merge the metadata from multiple providers.  For convenience
                in creating any metadata provider, KRAD includes the base class
                <emphasis role="keyword">org.kuali.rice.krad.data.provider.impl.MetadataProviderBase</emphasis>.
            </para>
            <para>
                Providers can be included in the system by declaring them in Spring and then hooking them up via the
                providers list in the module, in the same way as normally done with the default persistence or metadata
                providers.
                <programlisting>&lt;property name="providers">
    &lt;list>
        &lt;ref bean="jpaPersistenceProvider"/>
        &lt;ref bean="customPersistenceProvider"/>
        &lt;ref bean="metadataProvider"/>
        &lt;ref bean="customMetadataProvider"/>
    &lt;/list>
&lt;/property></programlisting>
              Each kind of provider defines methods to determine whether it can provide data for any given type, so the
              registry will search each provider in the list in the module and return the first provider that handles
              the given type.
            </para>
        </section>
        <section>
            <title>Accessing Metadata</title>
            <para>
                The metadata about data objects is available now directly via the
                <emphasis role="keyword">DataObjectService.wrap(..)</emphasis> method, which loads the metadata from the
                metadata repository and places it in a <emphasis role="keyword">DataObjectWrapper</emphasis>.  This
                wrapper gives access to such information as the primary keys, the business keys, the foreign keys, the
                attributes, the collections inside the data object, and the relationships to the data object.  It also
                provides methods to perform manual linking between foreign key and relationship values in case that
                is not possible or unwanted to do automatically through JPA.
            </para>
            <para>
                For example, if you wanted to get all of the primary key values from a data object, you could write the
                following:
                <programlisting>T dataObject = getDataObject();
DataObjectWrapper&lt;T> wrapper = getDataObjectService().wrap(dataObject);
Map&lt;String, Object> primaryKeyValues = wrapper.getPrimaryKeyValues();</programlisting>
            </para>
        </section>
        <section>
            <title>Queries</title>
            <para>In JPA there are several ways to execute queries. The following are the best practices
                that should be used when using JPA in Kuali applications. In general the order of
                consideration for a query should go as the following:
                <orderedlist>
                    <listitem>
                        <para>Use DataObjectService methods in service methods.</para>
                    </listitem>
                    <listitem>
                        <para>Create custom DAOs method to use NamedQuery in JPA.</para>
                    </listitem>
                    <listitem>
                        <para>Use Rice Criteria API if query is too complicated and would require
                            dynamic generation(String concatenation).</para>
                    </listitem>
                    <listitem>
                        <para>Use JPA Criteria API if query requires functions not supported in Rice
                            Criteria API.</para>
                    </listitem>
                </orderedlist>
                <emphasis role="bold"> Simple DataObjectService fetch by Primary Key</emphasis>
                <programlisting>CountryBo countryBo = getDataObjectService().find(CountryBo.class,code);

// Fetch by Compound Primary Key
final Map&lt;String, Object> map = new HashMap&lt;String, Object>();
map.put("countryCode", countryCode);
map.put("code", code);
StateBo stateBo = getDataObjectService().find(StateBo.class,new CompoundKey(map)));</programlisting>
                <emphasis role="bold">DataObjectService query for matching results</emphasis>
                <programlisting>// Fetch all matching results by countryCode and that have active equivalent to true
final Map&lt;String, Object> map = new HashMap&lt;String, Object>();
map.put("countryCode", countryCode);
map.put("active", Boolean.TRUE);

QueryResults&lt;PostalCodeBo> postalCodeBoQueryResults = getDataObjectService().
    findMatching(PostalCodeBo.class,QueryByCriteria.Builder.andAttributes(map).build());

// Fetch all Countries that have alternateCountryCode equal to value passed in
QueryByCriteria qbc = QueryByCriteria.Builder.forAttribute(
    KRADPropertyConstants.ALTERNATE_POSTAL_COUNTRY_CODE, alternateCode).build();
QueryResults&lt;CountryBo> countryBoQueryResults = getDataObjectService().findMatching(CountryBo.class,qbc);
List&lt;CountryBo> countryList = countryBoQueryResults.getResults();</programlisting>
                <emphasis role="bold"> DataObjectService query returning the count based on Criteria </emphasis>
                <programlisting>//Fetch count based on document id and principal id and current indicator being true
QueryByCriteria.Builder criteria = QueryByCriteria.Builder.create().setPredicates(
                                       equal(DOCUMENT_ID, documentId),
                                       equal(PRINCIPAL_ID, principalId),
                                       equal(CURRENT_INDICATOR, Boolean.TRUE));
criteria.setCountFlag(CountFlag.ONLY);
return getDataObjectService().findMatching(ActionTakenValue.class, criteria.build()).getTotalRowCount();</programlisting>
            </para>
            <para><emphasis role="bold">DataObjectService save</emphasis></para>
            <programlisting>// Fetch by Compound Primary Key
final Map&lt;String, Object> map = new HashMap&lt;String, Object>();
map.put("countryCode", countryCode);
map.put("code", code);
StateBo stateBo = getDataObjectService().find(StateBo.class,new CompoundKey(map)));

// make the StateBo inactive
stateBo.setActiveToDate(new Timestamp(System.currentTimeMillis());

// save the StateBo and get the updated instance
stateBo = getDataObjectService().save(stateBo);</programlisting>
            <para><emphasis role="bold">DataObjectService save with PersistenceOption</emphasis></para>
            <programlisting>// Fetch by Compound Primary Key
final Map&lt;String, Object> map = new HashMap&lt;String, Object>();
map.put("countryCode", countryCode);
map.put("code", code);
StateBo stateBo = getDataObjectService().find(StateBo.class,new CompoundKey(map)));

// make the StateBo inactive
stateBo.setActiveToDate(new Timestamp(System.currentTimeMillis());

// save the StateBo, include a PersistenceOption, and get the updated instance
stateBo = getDataObjectService().save(stateBo, PersistenceOption.FLUSH);</programlisting>
            <para><emphasis>PersistenceOptions</emphasis></para>
            <para>
                One or more persistence options can be passed to indicate whether or not linking should be performed prior to
                persistence.  By default, linking foreign key values on the wrapped data object is performed.  Below is a
                list of PersistionOption values.
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        FLUSH - Synchronize the persistence context to the underlying data store.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        LINK_KEYS - Synchronize the persistence context to the underlying data store, and
                        link values into foreign keys that are "read-only" according to the metadata of the data object.
                    </para>
                </listitem>
            </orderedlist>
            <para><emphasis role="bold">DataObjectService delete</emphasis></para>
            <programlisting>// Fetch by Compound Primary Key
final Map&lt;String, Object> map = new HashMap&lt;String, Object>();
map.put("countryCode", countryCode);
map.put("code", code);
StateBo stateBo = getDataObjectService().find(StateBo.class,new CompoundKey(map)));

// delete the StateBo
getDataObjectService().delete(stateBo);</programlisting>
            <para>
                <emphasis role="bold">Injecting the Shared Entity Manager</emphasis>
                <programlisting>// Add the following to your Spring DAO implementation to assign the appropriate Persistence Unit to your DAO
public class DocumentTypeDAOJpa implements DocumentTypeDAO {

    @PersistenceContext(unitName="kew")
    private EntityManager entityManager;

}</programlisting>
            </para>
            <para>
                <emphasis role="bold"> Simple example of Named Query in Rice</emphasis>
                <programlisting>// Fetch Application Document ID by Document ID
// Define constants for named query in DAO - In this case DocumentRouteHeaderDAOJpa
// Name your queries such that they start with the Entity name
// like @NamedQuery(name="ParameterBo.findAll", query="SELECT p FROM ParameterBo")
public static final String GET_APP_DOC_STATUS_NAME = "DocumentRouteHeaderValue.GetAppDocStatus";
public static final String GET_APP_DOC_STATUS_QUERY = "SELECT d.appDocStatus from "
            + "DocumentRouteHeaderValue as d where d.documentId = :documentId";

// Definition of NamedQuery on Queried Entity(DocumentRouteHeaderValue)
@NamedQuery(name=DocumentRouteHeaderDAOJpa.GET_APP_DOC_STATUS_NAME, query =
    DocumentRouteHeaderDAOJpa.GET_APP_DOC_STATUS_QUERY)

// Code to call NamedQuery
TypedQuery&lt;String> query = getEntityManager().createNamedQuery("DocumentRouteHeaderValue.GetAppDocId",String.class);
query.setParameter("documentId",documentId);

String applicationDocId = null;
if (query.getResultList() != null &amp;&amp; !query.getResultList().isEmpty()){
    applicationDocId = query.getResultList().get(0);
}

return applicationDocId;</programlisting>
                <emphasis role="bold">More Complex example of NamedQuery </emphasis>
                <programlisting>// Fetch all distinct document IDs by document type and application document ID
public static final String GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_NAME =
            "DocumentRouteHeaderValue.GetDocumentIdByDocTypeAndAppId";
public static final String GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_QUERY = "SELECT "
            + "DISTINCT(DH.documentId) FROM DocumentRouteHeaderValue DH, DocumentType DT "
            + "WHERE DH.appDocId = :appDocId AND DH.documentTypeId = DT.documentTypeId  AND DT.name = :name";

@NamedQuery(name=DocumentRouteHeaderDAOJpa.GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_NAME, query =
    DocumentRouteHeaderDAOJpa.GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_QUERY)

TypedQuery&lt;String> query = getEntityManager().createNamedQuery(GET_DOCUMENT_ID_BY_DOC_TYPE_APP_ID_NAME, String.class);
query.setParameter("appDocId",appId);
query.setParameter("name",documentTypeName);

return query.getResultList();</programlisting>
                <tip>
                    <para> When building named queries you must use an alias the object  "select
                            <emphasis role="bold">r</emphasis> from KUL_RICE_T <emphasis role="bold"
                            >r</emphasis>". If you get the below error you are probably missing an
                        alias.
                        <programlisting>Caused by: java.lang.ClassCastException:
                        org.eclipse.persistence.jpa.jpql.parser.NullExpression
                        cannot be cast to org.eclipse.persistence.jpa.jpql.parser.IdentificationVariable
                     </programlisting>
                    </para>
                </tip>
                <emphasis role="bold">Using Rice Criteria API </emphasis>
                <programlisting>// Example of Dynamic query, this query needs to add date checks dates if effectiveDate parameter is not null
// This should be in a DAO class - RuleDAOJpa in this case

public List&lt;RuleBaseValues> fetchAllCurrentRulesForTemplateDocCombination(String ruleTemplateId, List documentTypes,
        Timestamp effectiveDate) {
    QueryByCriteria.Builder builder = QueryByCriteria.Builder.create();
    List&lt;Predicate> predicates = new ArrayList&lt;Predicate>();
    predicates.add(equal("ruleTemplateId",ruleTemplateId));
    predicates.add(in("docTypeName", documentTypes));
    predicates.add(equal("active", Boolean.TRUE));
    predicates.add(equal("delegateRule",Boolean.FALSE));
    predicates.add(equal("templateRuleInd",Boolean.FALSE));

    if (effectiveDate != null) {
        predicates.add(lessThanOrEqual("activationDate",effectiveDate));
        predicates.add(greaterThanOrEqual("deactivationDate", effectiveDate));
    }

    List&lt;Predicate> datePredicateList = generateFromToDatePredicate(new Date());
    Predicate[] datePreds = generateFromToDatePredicate(new Date()).toArray(new Predicate[datePredicateList.size()]);
    predicates.add(and(datePreds));
    Predicate[] preds = predicates.toArray(new Predicate[predicates.size()]);
    builder.setPredicates(preds);
    QueryResults&lt;RuleBaseValues> results = getDataObjectService().findMatching(RuleBaseValues.class, builder.build());

    return results.getResults();
}

public List&lt;Predicate> generateFromToDatePredicate(Date date){
    List&lt;Predicate> datePredicates = new ArrayList&lt;Predicate>();

    Predicate orFromDateValue = or(lessThanOrEqual("fromDateValue",new Timestamp(date.getTime())), isNull("fromDateValue"));
    Predicate orToDateValue = or(greaterThanOrEqual("toDateValue",new Timestamp(date.getTime())), isNull("toDateValue"));

    datePredicates.add(orFromDateValue);
    datePredicates.add(orToDateValue);

    return datePredicates;
}</programlisting>
                <emphasis role="bold">Using JPA Criteria API</emphasis>
                <programlisting>// Using JPA Criteria Builder

public List&lt;RuleBaseValues> search(String docTypeName, String ruleId, String ruleTemplateId, String ruleDescription, String groupId,
        String principalId, Boolean delegateRule, Boolean activeInd, Map extensionValues, String workflowIdDirective) {
    CriteriaBuilder cb = getEntityManager().getCriteriaBuilder();
    CriteriaQuery&lt;RuleBaseValues> cq = cb.createQuery(RuleBaseValues.class);
    Root&lt;RuleBaseValues> root = cq.from(RuleBaseValues.class);
    List&lt;javax.persistence.criteria.Predicate> predicates = getSearchCriteria(root, cq, docTypeName, ruleTemplateId,
        ruleDescription, delegateRule, activeInd, extensionValues);

    if (ruleId != null) {
        predicates.add(cb.equal(root.get("id"),ruleId));
    }

    if (groupId != null) {
        predicates.add(cb.in(root.get("id")).value(getRuleResponsibilitySubQuery(groupId, cq)));
    }

    Collection&lt;String> kimGroupIds = new HashSet&lt;String>();
    Boolean searchUser = Boolean.FALSE;
    Boolean searchUserInWorkgroups = Boolean.FALSE;
        
    if ("group".equals(workflowIdDirective)) {
        searchUserInWorkgroups = Boolean.TRUE;
    } else if (StringUtils.isBlank(workflowIdDirective)) {
        searchUser = Boolean.TRUE;
        searchUserInWorkgroups = Boolean.TRUE;
    } else {
        searchUser = Boolean.TRUE;
    }
        
    if (!org.apache.commons.lang.StringUtils.isEmpty(principalId) &amp;&amp; searchUserInWorkgroups) {
        Principal principal = KimApiServiceLocator.getIdentityService().getPrincipal(principalId);

        if (principal == null) {
            throw new RiceRuntimeException("Failed to locate user for the given principal id: " + principalId);
        }

        kimGroupIds = KimApiServiceLocator.getGroupService().getGroupIdsByPrincipalId(principalId);
    }

    Subquery&lt;RuleResponsibilityBo> subquery
        = addResponsibilityCriteria(cq,kimGroupIds, principalId, searchUser, searchUserInWorkgroups);

    if (subquery != null){
        predicates.add(cb.in(root.get("id")).value(subquery));
    }

    cq.distinct(true);
    javax.persistence.criteria.Predicate[] preds = predicates.toArray(new javax.persistence.criteria.Predicate[predicates.size()]);
    cq.where(preds);
    TypedQuery&lt;RuleBaseValues> q = getEntityManager().createQuery(cq);

    return q.getResultList();
}

private Subquery&lt;RuleResponsibilityBo> getRuleResponsibilitySubQuery(String ruleRespName, CriteriaQuery&lt;RuleBaseValues> query) {
    CriteriaBuilder cb = getEntityManager().getCriteriaBuilder();
    Subquery&lt;RuleResponsibilityBo> subquery = query.subquery(RuleResponsibilityBo.class);
    Root fromResp = subquery.from(RuleResponsibilityBo.class);
    subquery.where(cb.equal(fromResp.get("ruleResponsibilityName"),ruleRespName));
    subquery.select(fromResp.get("ruleBaseValuesId"));

    return subquery;
}</programlisting>
                <emphasis role="bold">Miscellaneous JPA information </emphasis>
                <tip>
                    <para>
                        <programlisting>//Relationship foreign key updating can go wrong if missing
//"nullable" on JoinColumn.  It can insert null into the column instead of
//the actual value of the foreign entity key

public class RouteNodeInstance implements Serializable {
    @ManyToOne
    @JoinColumn(name="RTE_NODE_ID", <emphasis role="bold">nullable = false</emphasis>)
    private RouteNode routeNode;
}
                      </programlisting>
                    </para>
                </tip>
            </para>
        </section>
        <section>
          <title>Sequences</title>
          <para>
              For automatically generating values for identifier fields, JPA provides <emphasis role="keyword">@GeneratedValue</emphasis>
              to place on any field or method.  While this works for many databases like Oracle that have their own concepts
              of sequence objects, some databases like MySQL do not have sequence objects and need additional support.
              Kuali Rice uses the standard of "sequence tables" in MySQL that use the MyISAM auto increment feature to
              simulate sequences.  This has prompted the creation of <emphasis role="keyword">@PortableSequenceGenerator</emphasis>
              to work alongside <emphasis role="keyword">@GeneratedValue</emphasis> to provide automatic application support
              for both Oracle and MySQL.
          </para>
          <para>
              To use this feature, place it with any <emphasis role="keyword">@GeneratedValue</emphasis> annotation.
              <programlisting>@PortableSequenceGenerator(name = "TABLE_S")
@GeneratedValue(generator = "TABLE_S")
@Id
@Column(name = "TABLE_ID")
private String id;</programlisting>
              In this example, <emphasis role="keyword">TABLE_S</emphasis> is the name of the portable sequence generator,
              and by default, it is taken as the sequence name in the database.  In order to specify a separate generator
              name from the database sequence name, use the <emphasis role="keyword">name</emphasis> attribute for the
              generator name instead and add the <emphasis role="keyword">sequenceName</emphasis> attribute for the database
              sequence name.  Also, the generator can be configured to start at a specified value by using <emphasis role="keyword">initialValue</emphasis>.
              By default, it starts at 1000.
              <programlisting>@PortableSequenceGenerator(name = "TABLE_S_GEN", sequenceName = "TABLE_S", initialValue = 1)
@GeneratedValue(generator = "TABLE_S")
@Id
@Column(name = "TABLE_ID")
private String id;</programlisting>
          </para>
          <para>
              Some situations call for being able to access the sequences in Spring beans.  The <emphasis role="keyword">MaxValueIncrementerFactoryBean</emphasis>
              allows for this.  These sequences can then be used in situations where automatically placing them on data
              objects is not possible or desirable.
              <programlisting>&lt;bean id="tableIncrementer" class="org.kuali.rice.krad.data.platform.MaxValueIncrementerFactoryBean">
  &lt;property name="dataSource" ref="dataSource" />
  &lt;property name="incrementerName" value="TABLE_S" />
&lt;/bean></programlisting>
              This returns a <emphasis role="keyword">DataFieldMaxValueIncrementer</emphasis> which can be used to access
              the next values of the sequence, either through <emphasis role="keyword">nextIntValue</emphasis>, <emphasis role="keyword">nextLongValue</emphasis>,
              or <emphasis role="keyword">nextStringValue</emphasis>.
          </para>
        </section>
        <section>
            <title>Entity Attribute Converters</title>
            <para>
                Entity Attribute Converters - Converts the current state of the entity attribute value
                into a data store representation and back again.
            </para>
            <note>
              <para>
                When the KradEclipseLinkEntityManagerFactoryBean or the KradEntityManagerFactoryBean classes
                are used the Kuali Rice entity attribute converters are automatically registered within the
                persistence context.
              </para>
            </note>

            <para><emphasis role="bold">Auto Apply</emphasis></para>
            <para>
                The autoApply attribute of a converter may be set to 'true' or 'false'.  When set to true
                the JPA provider will use the converter to convert all entity attributes of the given type.
                If autoApply is set to false then a javax.persistence.Convert annotation will need to be added
                to all attributes that shall be converted, along with the Converter class.
            </para>
            <para>Converters are typically specified on a mapping using the @Convert annotation</para>
            <programlisting>
@Entity
public class Channel {
...
@Convert(converter = BooleanTFConverter.class)
@Column(name = "SUBSCRB_IND", nullable = false)
private boolean subscribable;
...
}
            </programlisting>
            <para> The current attribute converters available in Kuali Rice: <table frame="all" tabstyle="striped" pgwide="1">
                <title>Kuali Rice Standard Converters</title>
                <tgroup cols="3">
                    <colspec colnum="1" colname="name" colwidth="2.5*" align="left"/>
                    <colspec colnum="2" colname="desc" colwidth="6.0*" align="left"/>
                    <colspec colnum="3" colname="autoApply" colwidth="1.0*" align="center"/>
                    <thead>
                        <row>
                            <entry>JPA Field Converter Class</entry>
                            <entry>Description</entry>
                            <entry>Auto Apply</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                              <link xlink:show="new"
                                    xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/BooleanYNConverter.html">
                                BooleanYNConverter
                              </link>
                            </entry>
                          <entry>Converts java.lang.Boolean True or False values
                              to java.lang.String characters 'Y' or 'N' to be
                              persisted to the data store.  Data store values are
                              converted back to java.lang.Boolean True or False when
                              injected back into a data object.</entry>
                            <entry>YES</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/Boolean01BigDecimalConverter.html">Boolean01BigDecimalConverter</link></entry>
                            <entry>Converts java.lang.Boolean True or False values to java.math.BigDecimal
                              to be persisted to the data store.  Data store values
                              are converted back to java.lang.Boolean True or False values when injected
                              back into a data object.</entry>
                            <entry>NO</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/Boolean01Converter.html">Boolean01Converter</link></entry>
                            <entry>Converts java.lang.Boolean True or False values to
                                java.math.BigInteger to be persisted to the data store.
                                Data store values are converted back to
                                java.lang.Boolean True or False values when injected
                                back into a data object.</entry>
                            <entry>NO</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/BooleanAIConverter.html">BooleanAIConverter</link></entry>
                            <entry>Converts java.lang.Boolean True or False to
                                java.lang.String characters 'A' or 'I' (A - active,
                                I - inactive) to be persisted to the data store.
                                Data store values are converted back to
                                java.lang.Boolean True or False values when injected
                                back into a data object.</entry>
                            <entry>NO</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/BooleanTFConverter.html">BooleanTFConverter</link></entry>
                            <entry>Converts java.lang.Boolean True or False
                                to java.lang.String characters 'T' or 'F'
                                (T - true, F - false) to be persisted to the
                                data store.  Data store values are converted back
                                to java.lang.Boolean True or False values when
                                injected back into a data object.</entry>
                            <entry>NO</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/EncryptionConverter.html">EncryptionConverter</link></entry>
                            <entry>Calls the core service to encrypt/decrypt
                              values being persisted to and from the data store.</entry>
                            <entry>NO</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/HashConverter.html">HashConverter</link></entry>
                            <entry>Calls the core service to hash values
                              being persisted to the data store.</entry>
                            <entry>NO</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/InverseBooleanYNConverter.html">InverseBooleanYNConverter</link></entry>
                            <entry>Converts the java.lang.Boolean True or
                              False value to it's inverse java.lang.String
                              character representation to be persisted to the data store.
                              Data store values are converted back to their inverse
                              java.lang.Boolean True or False values when injected
                              back into a data object.</entry>
                            <entry>NO</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/KualiDecimalConverter.html">KualiDecimalConverter</link></entry>
                            <entry>Converts KualiDecimal values to BigDecimals
                              to be persisted to the datasource.  Data store
                              values are converted back to KualiDecimals when
                              injected back into a data object.</entry>
                            <entry>YES</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/KualiIntegerConverter.html">KualiIntegerConverter</link></entry>
                            <entry>Converts KualiIntegers to java.lang.Longs
                              to be persisted to the data store.  Data store
                              values are converted back to KualiIngeters when
                              injected back into a data object.</entry>
                            <entry>YES</entry>
                        </row>
                        <row>
                            <entry><link xlink:show="new" xlink:href="http://site.kuali.org/rice/${project.version}/apidocs/org/kuali/rice/krad/data/jpa/converters/KualiPercentConverter.html">KualiPercentConverter</link></entry>
                            <entry>converts KualiPercents to java.math.BigDecimal
                              to be persisted to the data store.  Data store
                              values are convert back to KualiPercents when
                              injected back into a data object.</entry>
                            <entry>YES</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table></para>
        </section>
    </section>
    <section>
        <title>Data Object Metadata</title>
        <para>
            In addition to providing the capability to map data objects to database tables, Rice provides different
            methods of defining additional information about an object in the form of metadata.  This includes not
            only the relationships between objects but display information as well, such as labels, value finders,
            and validation behaviors.
        </para>
        <para>
            Rice contains several metadata providers, which can access references to several different kinds of metadata
            throughout the system.  These providers are registered via the module configuration are all accessible via
            the <emphasis role="keyword">ProviderRegistry</emphasis>, but it is much more direct to obtain metadata by
            using the <emphasis role="keyword">MetadataRepository</emphasis>.  It has the capability to not only fetch
            all metadata in the system but also fetch metadata for a specific type.  It will return the metadata for
            that type from the first provider that supports the type.
        </para>
        <para>
            All metadata is processed through a single main metadata provider called the
            <emphasis role="keyword">CompositeMetadataProvider</emphasis>.  It processes the metadata by accessing a
            list of all specific metadata providers and merging their data to create one source of metadata for the
            system to use.  Rice defines a list of three core metadata providers: one for the database, one for
            annotations, and one for spring bean definitions.  It also provides a spring list hook called
            <emphasis role="keyword">additionalMetadataProviders</emphasis> that client applications can override to
            insert their own metadata.
            <programlisting>&lt;bean id="metadataProvider" class="org.kuali.rice.krad.data.provider.impl.CompositeMetadataProviderImpl">
    &lt;property name="providers" ref="metadataProviderList" />
&lt;/bean>
&lt;bean id="metadataProviderList" class="org.kuali.rice.core.framework.util.spring.ListMergeBeanFactory">
    &lt;constructor-arg>
        &lt;list>
            &lt;ref bean="coreMetadataProviders" />
            &lt;ref bean="additionalMetadataProviders" />
        &lt;/list>
    &lt;/constructor-arg>
&lt;/bean>
&lt;util:list id="coreMetadataProviders">
    &lt;ref bean="metadataProviderJpa" />
    &lt;ref bean="metadataProviderAnnotation" />
    &lt;ref bean="metadataProviderSpring" />
&lt;/util:list>
&lt;util:list id="additionalMetadataProviders" /></programlisting>
        </para>
        <para>
          Rice processes the providers in order, giving each one the option of overlaying information provided by
          earlier providers in the chain.  That means that database metadata is considered first but may be
          overridden by annotations, then by spring beans, and finally by client applications.  The default action
          is to merge data, but this can be overridden by the
          <emphasis role="keyword">MetadataMergeAction</emphasis>, either via the
          <emphasis role="keyword">@MergeAction</emphasis> annotation or the
          <emphasis role="keyword">mergeAction</emphasis> attribute in the XML.  The merge action can take on
          the following behaviors:
          <table frame="all" tabstyle="striped" pgwide="1">
            <title>Merge Actions</title>
            <tgroup cols="2">
              <colspec colnum="1" colname="name" colwidth="1.0*" align="left"/>
              <colspec colnum="2" colname="desc" colwidth="1.0*" align="left"/>
              <thead>
                <row>
                  <entry>Merge Action</entry>
                  <entry>Description</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>MERGE</entry>
                  <entry>
                    If a match is found (same data object or attribute name), the existing object will
                    be embedded inside of the new object and be used only to fill in missing values.
                  </entry>
                </row>
                <row>
                  <entry>REPLACE</entry>
                  <entry>
                    If a match is found (same data object or attribute name), the existing object will
                    be replaced completely by this one.
                  </entry>
                </row>
                <row>
                  <entry>REMOVE</entry>
                  <entry>
                    If a match is found (same data object or attribute name), the existing object will be
                    removed.  (Any attribute except that forming the key (type or attribute name) can be
                    left unset.)
                  </entry>
                </row>
                <row>
                  <entry>NO_OVERRIDE</entry>
                  <entry>
                    If a match is found (same data object or attribute name), the existing object will be
                    left alone.  The new object will only be included if there is not already an
                    existing object.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>
        <section>
            <title>Annotation Metadata Provider</title>
            <para>
                The annotation metadata provider will process all Java annotations on a data object class to include
                them in the system metadata repository.  These are applied directly after the JPA metadata is processed
                and will merge the JPA-based metadata into itself unless directed otherwise.
            </para>
            <para>
                A good example of using this provider is applying data dictionary attributes to a field in a data
                object.
                <programlisting>@Label("Travel Account Type Code")
@Description("Type code grouping for account")
@KeyValuesFinderClass(AccountTypeKeyValues.class)
private String accountTypeCode;</programlisting>
                For <emphasis role="keyword">accountTypeCode</emphasis>, the annotations define the label that will
                appear on the interface for any input fields, the description that will go along with the field if
                requested, and a key values finder class that will search for all possible values that can go into
                this field.
            </para>
            <para>
                The annotations can also define relationships between two objects that normally would not have a
                database link between them.
                <programlisting>private String foId;

@Relationship(foreignKeyFields="foId")
private Person fiscalOfficer;</programlisting>
                In this case, the relationships directs the metadata to load the
                <emphasis role="keyword">Person</emphasis> object using the foreign key field
                <emphasis role="keyword">foId</emphasis>.
            </para>
        </section>
        <section>
            <title>Spring Metadata Provider</title>
            <para>
                The spring metadata provider will process all spring beans that hold object metadata and include them
                in the system metadata repository.  These are applied directly after the annotation metadata is
                processed and will merge both the JPA-based metadata and the annotation metadata into itself unless
                directed otherwise.  This is especially useful when overriding metadata on Rice objects directly on the
                data level so it will be carried to all instances of this object on the interface.
            </para>
            <para>
                The spring beans can be used to create a metadata structure for an object rooted at
                <emphasis role="keyword">DataObjectMetadata</emphasis>.  For example, to override the above
                <emphasis role="keyword">accountTypeCode</emphasis> with a new label, add the following:
                <programlisting>&lt;bean parent="DataObjectMetadata" p:typeClassName="org.kuali.rice.krad.demo.travel.dataobject.TravelAccount">
    &lt;property name="attributes">
        &lt;list>
            &lt;bean parent="DataObjectAttribute"
                  p:name="accountTypeCode"
                  p:label="University Travel Account Type Code" />
        &lt;/list>
    &lt;/property>
&lt;/bean></programlisting>
                Instead of having the "Travel Account Type Code" this data object would now have the "University Travel
                Account Type Code."
            </para>
        </section>
    </section>
    <section>
        <title>Linking and Fetching</title>
        <para>The KRAD data module includes support for a number of different mechanisms to help
            ensure that object state is fully populated and related objects are properly linked
            together. These mechanisms encompass a number of different techniques including:<orderedlist>
                <listitem>
                    <para>Relationship Fetching</para>
                </listitem>
                <listitem>
                    <para>Reference Linking</para>
                </listitem>
                <listitem>
                    <para>Foreign Key Linking</para>
                </listitem>
            </orderedlist>The goal of these different techniques is to use information available at
            runtime to "fill in the blanks" for relationships and/or foreign key fields on a data
            object. This functionality can be accessed via various methods provided on the
                <code>DataObjectWrapper</code>. There are two primary ways to model these types of
            relationships, either with a simple relationship or one with a redundant foreign key
            field. In order to better understand how linking and fetching works, it's important to
            understand the distinction between these two cases.</para>
        <para>It is easiest to demonstrate this using examples. We will start with an example data
            object (using JPA annotations) that has a simple
            relationship:<programlisting>
@Entity
public class EntityOne {

    @Id
    @GeneratedValue
    @Column(name = "ID")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "TWO_ID")
    private EntityTwo two;

}

@Entity
public class EntityTwo {
 
    @Id
    @GeneratedValue
    @Column(name = "ID")
    private String id;
 
    @Column(name = "VAL")
    private String value;
 
}
</programlisting></para>
        <para>In this example, we have EntityOne with a relationship to EntityTwo. The foreign key
            field which relates EntityOne to EntityTwo is the "id" field on EntityTwo.</para>
        <para>Now, let's consider the redundant foreign key
            case:<programlisting>
@Entity
public class EntityOneWithFK {

    @Id
    @GeneratedValue
    @Column(name = "ID")
    private Long id;
<emphasis role="bold">
    @Column(name = "TWO_ID", insertable = false, updatable = false)
    private String twoId;</emphasis>

    @ManyToOne
    @JoinColumn(name = "TWO_ID")
    private EntityTwo two;

}

@Entity
public class EntityTwo {
 
    @Id
    @GeneratedValue
    @Column(name = "ID")
    private String id;
 
    @Column(name = "VAL")
    private String value;
 
}
</programlisting></para>
        <para>Notice the addition here of the "twoId" field. In this case both the "twoId" field and
            the "id" field on EntityTwo represent the same foreign key in the relationship. Hence
            the redundancy of this approach. It is logical to wonder why the redundant key is even
            necessary. The answer is that it is not, and it should not be considered best practice
            (with JPA at least) to do this. However, with legacy KNS applications based on Apache
            OJB, this was the typical approach. Therefore, we still need to support both of these
            models in order to ease migration. </para>
        <para>As we discuss each of the fetching and linking techniques in the next few sections,
            keep these two different relationship scenarios in mind.</para>
        <section>
            <title>Relationship Fetching</title>
            <para>Relationship fetching allows for a related object to be fetched based on available
                foreign key values on the object. This provides a facility to load the full state of
                a related object when only foreign key values have been populated on the parent
                object. This is a common enough operation that it has been implemented as a
                general-purpose utility with the <code>fetchRelationship</code> methods on the
                    <code>DataObjectWrapper</code>. When fetching a relationship, the name of the
                relationship to fetch is supplied (relative to the parent object) along with whether
                or not a redundant foreign key field should be used as the source of the foreign key
                value. It is also possible to specify whether or not any dangling relationships
                should be nullified if no data object is found for the given foreign key
                values.</para>
            <para>Relationship fetching can use either the redundant foreign key field (if one
                exists) or the current value of the foreign key field on the related object in the
                case of a simple relationship. When executed, it will use the foreign key value to
                query the <code>DataObjectService</code> for that related object and then replace
                the original related object on the parent with the resulting value.</para>
            <para>To best deomonstrate the logic, let's look at an example:</para>
            <programlisting>
EntityOne one = new EntityOne();

// create a partially initialized instance of EntityTwo to hold the foreign key value of "100"
EntityTwo two = new EntityTwo();
two.setId(100);
one.setTwo(two);

DataObjectWrapper&lt;EntityOne> oneWrapped = dataObjectService.wrap(one);

// fetch relationship, useForeignKeyAttribute = false, nullifyDanglingRelationsip = true
oneWrapped.fetchRelationship("two", false, true); 

// now, the "two" field on EntityOne holds our fetched instance of EntityTwo with id of "100"
EntityTwo fetchedTwo = one.getTwo();
</programlisting>
            <para>Note that in the above example if there was no instance of <code>EntityTwo</code>
                with an id of "100" in the data store, then <code>one.getTwo()</code> would return
                null after the call to fetch the relationship. This is because
                    <code>nullifyDanglingRelationship</code> was set to "true" when the method was
                executed.</para>
            <para>More detailed documentation on the <code>fetchRelationship</code> method can be
                found in the JavaDocs for the <code>DataObjectWrapper</code>.</para>
        </section>
        <section>
            <title>Reference Linking</title>
            <para>Reference Linking is a feature which allows for ensuring that relationships and
                foreign key state are populated and kept in sync as changes are made to a data
                object. This may include fetching relationships as keys are changed that would
                necessitate updating the object graph, as well as keeping foreign keys in sync in
                the scenario where redundant foreign key fields are being used.</para>
            <para>Reference linking takes as input a data object and a set of property paths
                (relative to the given object) which have been modified. The
                    <code>ReferenceLinker</code> will then examine those modified paths and make a
                decision on how best to synchronize the keys and populate relationships. It requires
                a set of changes to the object to be specified so as to eliminate ambiguity on what
                the linking process should do, as well as allow the process to be optimized so that
                it does not have to analyze and link the entire related object graph when only a
                portion of the data has been modified.</para>
            <para>The set of modified property paths which are supplied to the reference linker can
                be simple or nested property paths. The reference linking feature itself was
                designed with the goal of supporting population of missing object state when
                modifications are occurring to a data object. The most typical case for this in KRAD
                is during the data binding process that Spring MVC performs. However, the reference
                linking feature itself does not assume anything about how the changes are made to
                the data object, it just needs to know what has been modified. This allows the API
                for reference linking to remain simple.</para>
            <para>Reference linking can be executed using the <code>linkChanges</code> method on the
                    <code>DataObjectWrapper</code>. Let's demonstrate with an example:</para>
            <programlisting>
EntityOne one = /* a new or existing instance of Entity One */
DataObjectWrapper&lt;EntityOne> oneWrapped = dataObjectService.wrap(one);

// set the value of the id for the related EntityTwo to "100"
oneWrapped.setPropertyValue("two.id", 100);

// execute the reference linking, this will notice that we've changed our foreign key value
// for our reference to EntityTwo and will fetch that relationship for us
Set&lt;String> changes = Sets.newHashSet("two.id");
oneWrapped.linkChanges(changes);

// now, the "two" field on EntityOne holds our fetched instance of EntityTwo with id of "100"
EntityTwo fetchedTwo = one.getTwo();
</programlisting>
            <para>Notice the reference in the comments above to fetching a relationship. In fact,
                the reference linking process itself leverages the relationship fetching
                functionality that we talked about in the previous section. In reality, it takes the
                set of changes and determines which relationships to fetch and which foreign key
                values (if multiple exist for the relationship) should be used to perform that
                fetching. This insulates KRAD applications from having to perform a lot of this type
                of logic manually in custom controllers and takes full advantage of the metadata
                that the data framework has available to it when reconciling data object
                state.</para>
        </section>
        <section>
            <title>Foreign Key Linking</title>
            <para>Foreign key linking only applies to situations where there are redundant foreign
                key fields on a data object or any other data objects that it is related to. This
                linking operation can be executed against a data object and it will ensure that any
                redundant foreign key values are populated based on the foreign key values stored in
                the related data objects. It then recurses through the object graph and performs the
                same operation on all related data objects.</para>
            <para>This operation is often paired with persistence of the data object itself. This is
                because primary key values which are used in relationships are often generated at
                the time that an object is saved. This is typically done using a database sequence
                or similar technique. In these cases, the value for a foreign key field may not be
                known until <emphasis role="bold">after</emphasis> persistence has occurred and the
                key values have been generated. As a result, there is a shortcut to execute foreign
                key linking as part of the <code>save</code> operation on
                    <code>DataObjectService</code> by using a persistence option.</para>
            <para>The following example demonstrates this usage:</para>
            <programlisting>
EntityOneWithFK one = new EntityOneWithFK();
EntityTwo two = new EntityTwo();
two.setValue("...");
one.setTwo(two);

// in this case, both the primary key for "one" and "two" are generated when saved, in order to
// ensure that "twoId" gets populated we need to link the foreign keys as part of the save

one = dataObjectService.save(one, PersistenceOption.LINK_KEYS);

// now all of our ids should be generated and the value for "twoId" should match "two.id"
assert one.getId() != null;
assert one.getTwo().getId() != null;
assert one.getTwoId() != null;
assert one.getTwoId() == one.getTwo().getId();
</programlisting>
            <para>If we had not used the <code>LINK_KEYS</code> persistence option, then the value
                for <code>one.getTwoId()</code> after the save would have still been null since JPA
                will not populate this value for us after a persist/merge because the mapping has
                updatable and insertable set to "false".</para>
            <para>In addition to automatic execution of foreign key linking using the
                    <code>LINK_KEYS</code> persistence option, it is also possible to execute this
                linking manually using the <code>linkForeignKeys</code> method on the
                    <code>DataObjectWrapper</code>.</para>
        </section>
    </section>  
</chapter>
